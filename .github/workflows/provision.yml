name: Provision Mosuon Cluster Infrastructure

on:
  push:
    branches: [ main ]
    paths:
      - 'apps/**'
      - 'manifests/**'
      - 'scripts/**'
      - '.github/workflows/provision.yml'
  workflow_dispatch:
    inputs:
      enable_cleanup:
        description: 'Enable cluster cleanup (DANGEROUS - deletes all data). Default: false.'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      force_reprovision:
        description: 'Force reprovisioning (cleanup + reinstall). Requires enable_cleanup=true.'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  provision:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      # Mosuon-specific domains and configuration
      ARGOCD_DOMAIN: ${{ secrets.ARGOCD_DOMAIN || 'argocd.ultimatestats.co.ke' }}
      GRAFANA_DOMAIN: ${{ secrets.GRAFANA_DOMAIN || 'grafana.ultimatestats.co.ke' }}
      ANALYTICS_DOMAIN: ${{ secrets.ANALYTICS_DOMAIN || 'analytics.ultimatestats.co.ke' }}
      API_DOMAIN: ${{ secrets.API_DOMAIN || 'api.ultimatestats.co.ke' }}
      UI_DOMAIN: ${{ secrets.UI_DOMAIN || 'ultimatestats.co.ke' }}
      DB_NAMESPACE: ${{ secrets.DB_NAMESPACE || 'infra' }}
      MONITORING_NAMESPACE: ${{ secrets.MONITORING_NAMESPACE || 'infra' }}
      APP_NAMESPACE: ${{ secrets.APP_NAMESPACE || 'mosuon' }}
      CLUSTER_NAME: ${{ secrets.CLUSTER_NAME || 'mosuon-prod' }}
      SSH_HOST: ${{ secrets.SSH_HOST || '207.180.237.35' }}
      
      # Cleanup disabled by default
      ENABLE_CLEANUP: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.enable_cleanup == 'true' && 'true' || 'false' }}
      FORCE_REPROVISION: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.force_reprovision == 'true' && 'true' || 'false' }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Display workflow configuration
        run: |
          echo "::group::Workflow Configuration"
          echo "Cluster: ${CLUSTER_NAME}"
          echo "SSH Host: ${SSH_HOST}"
          echo "ArgoCD Domain: ${ARGOCD_DOMAIN}"
          echo "Grafana Domain: ${GRAFANA_DOMAIN}"
          echo "Analytics Domain: ${ANALYTICS_DOMAIN}"
          echo "API Domain: ${API_DOMAIN}"
          echo "UI Domain: ${UI_DOMAIN}"
          echo "DB Namespace: ${DB_NAMESPACE}"
          echo "App Namespace: ${APP_NAMESPACE}"
          echo "Cleanup Mode: ${ENABLE_CLEANUP}"
          echo "Force Reprovision: ${FORCE_REPROVISION}"
          echo "::endgroup::"

      - name: Install DevOps tools
        uses: ./.github/actions/install-devops-tools

      - name: Install PostgreSQL client and Python
        run: |
          echo "::group::Installing PostgreSQL client and Python"
          # Check if already installed (idempotent)
          if command -v psql &> /dev/null; then
            echo "PostgreSQL client already installed"
            psql --version
          else
            sudo apt-get update -y
            sudo apt-get install -y postgresql-client
            psql --version
          fi
          
          if command -v python3 &> /dev/null; then
            echo "Python3 already installed"
            python3 --version
          else
            sudo apt-get install -y python3
            python3 --version
          fi
          
          # Install jq if missing
          if ! command -v jq &> /dev/null; then
            sudo apt-get install -y jq
          fi
          echo "::endgroup::"

      - name: Configure kubeconfig
        id: kubeconfig_setup
        env:
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          echo "::group::Configuring kubeconfig"
          if [ -z "$KUBE_CONFIG_B64" ]; then
            echo "‚ùå KUBE_CONFIG secret not provided"
            echo "Please set up the Kubernetes cluster and add KUBE_CONFIG to GitHub secrets"
            echo "kubeconfig_ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | tr -d '[:space:]' | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          export KUBECONFIG=~/.kube/config
          
          echo "Testing cluster connectivity..."
          if kubectl cluster-info >/dev/null 2>&1; then
            echo "‚úÖ Successfully connected to Kubernetes cluster"
            kubectl get nodes
            echo "kubeconfig_ready=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to connect to cluster"
            echo "kubeconfig_ready=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "::endgroup::"

      - name: Make scripts executable
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        run: |
          echo "::group::Making scripts executable"
          find scripts -type f -name "*.sh" -exec chmod +x {} \;
          echo "‚úÖ Scripts are executable"
          ls -la scripts/infrastructure/
          echo "::endgroup::"

      - name: Create required namespaces
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        run: |
          echo "::group::Creating namespaces"
          NAMESPACES="${DB_NAMESPACE} ${APP_NAMESPACE} argocd"
          for ns in $NAMESPACES; do
            kubectl create namespace "$ns" --dry-run=client -o yaml | kubectl apply -f -
            echo "‚úì Namespace: $ns"
          done
          echo "::endgroup::"

      - name: Create registry-credentials secrets
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        env:
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME || 'codevertex' }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
          REGISTRY_EMAIL: ${{ secrets.REGISTRY_EMAIL || 'codevertexitsolutions@gmail.com' }}
          REGISTRY_SERVER: docker.io
        run: |
          echo "::group::Creating registry credentials"
          
          if [ -z "${REGISTRY_PASSWORD}" ]; then
            echo "‚ö†Ô∏è  REGISTRY_PASSWORD not set - skipping registry secret creation"
            echo "‚ö†Ô∏è  Pods may fail with ImagePullBackOff if Docker Hub rate limit is exceeded"
            echo "::endgroup::"
            exit 0
          fi
          
          NAMESPACES="${DB_NAMESPACE} ${APP_NAMESPACE} argocd"
          for ns in $NAMESPACES; do
            kubectl create secret docker-registry registry-credentials \
              --docker-server="${REGISTRY_SERVER}" \
              --docker-username="${REGISTRY_USERNAME}" \
              --docker-password="${REGISTRY_PASSWORD}" \
              --docker-email="${REGISTRY_EMAIL}" \
              -n "$ns" \
              --dry-run=client -o yaml | kubectl apply -f -
            echo "‚úì Created registry-credentials in: $ns"
            
            # Patch default service account to use registry-credentials
            if kubectl get sa default -n "$ns" >/dev/null 2>&1; then
              kubectl patch sa default -n "$ns" --type='json' \
                -p='[{"op":"add","path":"/imagePullSecrets","value":[{"name":"registry-credentials"}]}]' 2>/dev/null || true
            fi
          done
          
          echo "‚úÖ Registry credentials setup complete"
          echo "::endgroup::"

      - name: Check cluster health
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        run: |
          echo "::group::Cluster Health Check"
          echo "Checking cluster status..."
          
          kubectl get nodes || true
          READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c "Ready" || echo "0")
          TOTAL_NODES=$(kubectl get nodes --no-headers 2>/dev/null | wc -l || echo "0")
          
          if [ "$READY_NODES" -eq 0 ] && [ "$TOTAL_NODES" -gt 0 ]; then
            echo "‚ö†Ô∏è  Warning: Cluster has nodes but none are Ready"
          elif [ "$READY_NODES" -gt 0 ]; then
            echo "‚úÖ Cluster is healthy (${READY_NODES}/${TOTAL_NODES} nodes Ready)"
          fi
          
          echo "::endgroup::"

      - name: Install storage provisioner (idempotent)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 10
        run: |
          echo "::group::Installing Storage Provisioner"
          echo "This step is required before installing databases (for PVCs)"
          ./scripts/infrastructure/install-storage-provisioner.sh
          echo "‚úÖ Storage provisioner installed"
          echo "::endgroup::"

      - name: Configure ingress controller (idempotent)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 10
        run: |
          echo "::group::Configuring NGINX Ingress Controller"
          ./scripts/infrastructure/configure-ingress-controller.sh
          echo "‚úÖ Ingress controller configured"
          echo "::endgroup::"

      - name: Install cert-manager (idempotent)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 10
        run: |
          echo "::group::Installing cert-manager"
          ./scripts/infrastructure/install-cert-manager.sh
          echo "‚úÖ cert-manager installed"
          echo "::endgroup::"

      - name: Install Vertical Pod Autoscaler (VPA)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 10
        continue-on-error: true
        run: |
          echo "::group::Installing VPA"
          
          # Check if VPA is already installed
          if kubectl get deployment vpa-recommender -n kube-system >/dev/null 2>&1; then
            echo "‚úÖ VPA is already installed"
            kubectl get pods -n kube-system | grep vpa || true
          else
            echo "Installing VPA from official release..."
            kubectl apply -f https://github.com/kubernetes/autoscaler/releases/download/vertical-pod-autoscaler-1.1.2/vpa-v1.1.2.yaml || {
              echo "‚ö†Ô∏è VPA installation failed - this is optional, continuing..."
            }
            
            # Wait for VPA components
            echo "Waiting for VPA components to be ready..."
            kubectl rollout status deployment/vpa-recommender -n kube-system --timeout=120s || true
            kubectl rollout status deployment/vpa-updater -n kube-system --timeout=120s || true
            kubectl rollout status deployment/vpa-admission-controller -n kube-system --timeout=120s || true
            
            echo "VPA components:"
            kubectl get pods -n kube-system | grep vpa || echo "VPA pods not yet ready"
          fi
          
          echo "::endgroup::"

      - name: Install databases (PostgreSQL & Redis)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 20
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          NAMESPACE: ${{ env.DB_NAMESPACE }}
          ENABLE_CLEANUP: ${{ env.ENABLE_CLEANUP }}
        run: |
          echo "::group::Installing Shared Databases (PostgreSQL & Redis in ${DB_NAMESPACE} namespace)"
          ./scripts/infrastructure/install-databases.sh
          echo "‚úÖ Shared databases installed"
          echo "::endgroup::"

      - name: Create game-stats database
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 10
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          SERVICE_DB_NAME: game_stats
          SERVICE_DB_USER: game_stats_user
          APP_NAME: game-stats-api
          NAMESPACE: ${{ env.APP_NAMESPACE }}
          DB_NAMESPACE: ${{ env.DB_NAMESPACE }}
        run: |
          echo "::group::Creating game-stats database"
          ./scripts/infrastructure/create-service-database.sh
          echo "‚úÖ Database created for game-stats"
          echo "::endgroup::"

      - name: Create game-stats-api secrets
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 5
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          SERVICE_NAME: game-stats-api
          NAMESPACE: ${{ env.APP_NAMESPACE }}
          DB_NAMESPACE: ${{ env.DB_NAMESPACE }}
          DB_NAME: game_stats
          DB_USER: game_stats_user
        run: |
          echo "::group::Creating game-stats-api secrets"
          ./scripts/infrastructure/create-service-secrets.sh
          echo "‚úÖ Secrets created for game-stats-api"
          echo "::endgroup::"

      - name: Create Metabase database
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 10
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          SERVICE_DB_NAME: metabase
          SERVICE_DB_USER: metabase_user
          APP_NAME: metabase
          NAMESPACE: ${{ env.DB_NAMESPACE }}
          DB_NAMESPACE: ${{ env.DB_NAMESPACE }}
        run: |
          echo "::group::Creating Metabase database"
          ./scripts/infrastructure/create-service-database.sh
          echo "‚úÖ Database created for Metabase"
          echo "::endgroup::"

      - name: Create Metabase secrets
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 5
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          METABASE_EMBEDDING_KEY: ${{ secrets.METABASE_EMBEDDING_KEY }}
          DB_NAMESPACE: ${{ env.DB_NAMESPACE }}
        run: |
          echo "::group::Creating Metabase secrets"
          
          # Generate embedding key if not provided
          EMBEDDING_KEY="${METABASE_EMBEDDING_KEY:-$(openssl rand -hex 32)}"
          
          kubectl create secret generic metabase-secrets \
            -n "${DB_NAMESPACE}" \
            --from-literal=MB_DB_PASS="${POSTGRES_PASSWORD}" \
            --from-literal=MB_EMBEDDING_SECRET_KEY="${EMBEDDING_KEY}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "‚úÖ Secrets created for Metabase"
          echo "::endgroup::"

      - name: Install Argo CD (idempotent)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 15
        env:
          ARGOCD_DOMAIN: ${{ env.ARGOCD_DOMAIN }}
          VPS_IP: ${{ env.SSH_HOST }}
        run: |
          echo "::group::Installing Argo CD"
          ./scripts/infrastructure/install-argocd.sh
          echo "‚úÖ ArgoCD installed"
          echo "::endgroup::"

      - name: Bootstrap Argo CD applications (app-of-apps)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        run: |
          echo "::group::Bootstrapping Argo CD applications"
          
          # Apply the root Application that manages apps under apps/
          if [ -f apps/root-app.yaml ]; then
            kubectl apply -f apps/root-app.yaml
            echo "‚úÖ root Application applied"
          fi
          
          # Apply individual applications
          echo "Applying individual ArgoCD Applications (idempotent)..."
          for app_file in apps/*/app.yaml; do
            if [ -f "$app_file" ]; then
              kubectl apply -f "$app_file" || echo "‚ö†Ô∏è Failed to apply $app_file"
              echo "‚úì Applied: $app_file"
            fi
          done
          
          echo ""
          echo "Current ArgoCD Applications:"
          kubectl get applications -n argocd || true
          echo "::endgroup::"

      - name: Install Monitoring (Prometheus + Grafana)
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        timeout-minutes: 20
        continue-on-error: true
        env:
          GRAFANA_DOMAIN: ${{ env.GRAFANA_DOMAIN }}
          NAMESPACE: ${{ env.MONITORING_NAMESPACE }}
        run: |
          echo "::group::Installing Monitoring Stack"
          
          # Add Prometheus community Helm repo
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          
          # Install kube-prometheus-stack
          helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
            --namespace "${NAMESPACE}" \
            --set grafana.enabled=true \
            --set grafana.ingress.enabled=true \
            --set grafana.ingress.ingressClassName=nginx \
            --set grafana.ingress.hosts[0]="${GRAFANA_DOMAIN}" \
            --set grafana.ingress.tls[0].hosts[0]="${GRAFANA_DOMAIN}" \
            --set grafana.ingress.tls[0].secretName=grafana-tls \
            --set "grafana.ingress.annotations.cert-manager\\.io/cluster-issuer=letsencrypt-prod" \
            --set prometheus.prometheusSpec.retention=7d \
            --set prometheus.prometheusSpec.resources.requests.memory=256Mi \
            --set prometheus.prometheusSpec.resources.limits.memory=512Mi \
            --wait --timeout=15m || {
              echo "‚ö†Ô∏è  Monitoring installation encountered issues"
              echo "Will continue - monitoring can sync later via ArgoCD"
            }
          
          echo "‚úÖ Monitoring stack installed"
          echo "::endgroup::"

      - name: Verify Ingress Configuration
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        continue-on-error: true
        run: |
          echo "::group::Verifying Ingress Configuration"
          echo "All ingress resources:"
          kubectl get ingress -A
          echo ""
          echo "Certificates:"
          kubectl get certificates -A 2>/dev/null || echo "No certificates found"
          echo "::endgroup::"

      - name: Summary
        if: steps.kubeconfig_setup.outputs.kubeconfig_ready == 'true'
        env:
          ARGOCD_DOMAIN: ${{ env.ARGOCD_DOMAIN }}
          GRAFANA_DOMAIN: ${{ env.GRAFANA_DOMAIN }}
          ANALYTICS_DOMAIN: ${{ env.ANALYTICS_DOMAIN }}
          API_DOMAIN: ${{ env.API_DOMAIN }}
          UI_DOMAIN: ${{ env.UI_DOMAIN }}
          DB_NAMESPACE: ${{ env.DB_NAMESPACE }}
          APP_NAMESPACE: ${{ env.APP_NAMESPACE }}
          SSH_HOST: ${{ env.SSH_HOST }}
        run: |
          echo "::group::Cluster Infrastructure Provisioning Complete"
          echo ""
          echo "============================================"
          echo "üéâ Mosuon Cluster Provisioned Successfully!"
          echo "============================================"
          echo ""
          echo "üì¶ Infrastructure Components:"
          echo "  ‚úÖ Storage provisioner installed"
          echo "  ‚úÖ NGINX Ingress Controller configured"
          echo "  ‚úÖ cert-manager installed with LetsEncrypt"
          echo "  ‚úÖ Vertical Pod Autoscaler (VPA) installed"
          echo "  ‚úÖ PostgreSQL installed (${DB_NAMESPACE} namespace)"
          echo "  ‚úÖ Redis installed (${DB_NAMESPACE} namespace)"
          echo "  ‚úÖ Metabase Analytics installed (${DB_NAMESPACE} namespace)"
          echo "  ‚úÖ Argo CD installed"
          echo "  ‚úÖ Monitoring Stack installed (Prometheus + Grafana)"
          echo ""
          echo "üìà Autoscaling Configuration:"
          echo "  ‚úÖ HPA: Enabled for game-stats-api (1-3 replicas)"
          echo "  ‚úÖ HPA: Enabled for game-stats-ui (1-3 replicas)"
          echo "  ‚úÖ VPA: Recommendation mode for all apps"
          echo "  ‚úÖ View VPA recommendations: kubectl get vpa -A"
          echo ""
          echo "üéÆ Game Stats Application:"
          echo "  ‚úÖ Database: game_stats"
          echo "  ‚úÖ Secrets: game-stats-api-secrets"
          echo "  ‚úÖ Namespace: ${APP_NAMESPACE}"
          echo ""
          echo "üìä Analytics (Metabase):"
          echo "  ‚úÖ Database: metabase"
          echo "  ‚úÖ Secrets: metabase-secrets"
          echo "  ‚úÖ Namespace: ${DB_NAMESPACE}"
          echo ""
          echo "üåê Access URLs:"
          echo "  ArgoCD:    https://${ARGOCD_DOMAIN}"
          echo "  Grafana:   https://${GRAFANA_DOMAIN}"
          echo "  Analytics: https://${ANALYTICS_DOMAIN}"
          echo "  API:       https://${API_DOMAIN}"
          echo "  Frontend:  https://${UI_DOMAIN}"
          echo ""
          echo "üîê Credentials:"
          echo "  PostgreSQL: kubectl get secret postgresql -n ${DB_NAMESPACE} -o jsonpath='{.data.postgres-password}' | base64 -d"
          echo "  Redis:      kubectl get secret redis -n ${DB_NAMESPACE} -o jsonpath='{.data.redis-password}' | base64 -d"
          echo "  ArgoCD:     kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d"
          echo "  Grafana:    kubectl get secret prometheus-grafana -n ${DB_NAMESPACE} -o jsonpath='{.data.admin-password}' | base64 -d"
          echo "  Metabase:   First login creates admin at https://${ANALYTICS_DOMAIN}/setup"
          echo ""
          echo "üìã Next Steps:"
          echo "  1. Configure DNS: Point domains to VPS IP (${SSH_HOST})"
          echo "  2. Access ArgoCD: https://${ARGOCD_DOMAIN}"
          echo "  3. Deploy apps: Run build.sh in game-stats-api and game-stats-ui"
          echo "  4. Setup Metabase: Visit https://${ANALYTICS_DOMAIN}/setup"
          echo "  5. Verify TLS: Check certificate status after DNS propagation"
          echo ""
          echo "üìö Documentation:"
          echo "  - Cluster setup: docs/CLUSTER-SETUP-WORKFLOW.md"
          echo "  - GitHub secrets: docs/github-secrets.md"
          echo "  - Provisioning: docs/provisioning.md"
          echo "  - Operations: docs/OPERATIONS-RUNBOOK.md"
          echo "::endgroup::"
